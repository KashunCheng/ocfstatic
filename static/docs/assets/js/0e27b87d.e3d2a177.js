"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[8738],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),l=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=l(n),d=o,f=h["".concat(p,".").concat(d)]||h[d]||u[d]||a;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},5190:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={title:"Printhost"},i=void 0,s={unversionedId:"staff/backend/printhost",id:"staff/backend/printhost",title:"Printhost",description:"Introduction",source:"@site/docs/staff/backend/printhost.md",sourceDirName:"staff/backend",slug:"/staff/backend/printhost",permalink:"/docs/staff/backend/printhost",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/staff/backend/printhost.md",tags:[],version:"current",frontMatter:{title:"Printhost"},sidebar:"tutorialSidebar",previous:{title:"Munin",permalink:"/docs/staff/backend/munin"},next:{title:"Prometheus",permalink:"/docs/staff/backend/prometheus"}},p={},l=[{value:"Introduction",id:"introduction",level:2},{value:"CUPS pipeline overview",id:"cups-pipeline-overview",level:2},{value:"Filters",id:"filters",level:3},{value:"Drivers",id:"drivers",level:3},{value:"Print accounting",id:"print-accounting",level:2},{value:"Desktop notifications",id:"desktop-notifications",level:3},{value:"See also",id:"see-also",level:2}],c={toc:l};function u(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"The OCF's print server is based around two components: ",(0,o.kt)("a",{parentName:"p",href:"https://www.cups.org/documentation.html"},"CUPS"),", the\nstandard UNIX print server, and a custom print accounting system contained in\nthe ocflib API. CUPS is responsible for receiving print jobs over the network,\nconverting documents to a printer-friendly format, and delivering processed\njobs to one of the available printers. The OCF's print accounting system,\nnicknamed enforcer after one of the scripts, plugs into CUPS as a hook that\nlooks at jobs before and after going to the printer. It records jobs in a\ndatabase that keeps track of how many pages each user has printed, rejecting\njobs that go over quota. The high level flow of data through the print system\nlooks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"   [Application]\n         +\n         | PDF or PS document\n         v\n[Print spool (CUPS)]\n         +\n         | Raw document\n         v\n[Filter(s) (ocfps)]\n         +\n         | Converted PS document\n         v\n[Backend (Tea4CUPS)]\n         +\n         |  Accept or reject\n         +<------------------+[Page counter (enforcer)]\n         |                               ^\n         v                               |\n     [Printer]                           |                 Remaining quota\n         +                               +-------+/      \\<---------------+/             \\\n         | Status/completion time                 |ocflib|                 |Jobs database|\n         v                               +-------\x3e\\      /+---------------\x3e\\             /\n     [Backend]                           |                 Job table entry\n         +                               |\n         |                               +\n         +----------------------\x3e[Enforcer (again)]\n         |  Log success/failure\n         v\n[Print spool logger]\n")),(0,o.kt)("h2",{id:"cups-pipeline-overview"},"CUPS pipeline overview"),(0,o.kt)("p",null,"The first stage of printing is handled by the application that sends the print\njob, such as Evince. The application opens up a system print dialog, which gets\na list of available printers and options from the local CUPS client, which in\nturn gets it from the printhost. The application renders the desired pages to a\nPostScript, PDF, or other CUPS-compatible format, then sends it to the\nprinthost."),(0,o.kt)("p",null,"The CUPS server on the printhost receives the job and print options and queues\nthe job for printing. The actual document, plus metadata including user-set\noptions, is stored in the print spool at ",(0,o.kt)("inlineCode",{parentName:"p"},"/var/spool/cups")," until a printer\nbecomes available to print it. The document is converted into a more\nprinter-friendly format before it actually reaches the printer. Once it's ready\nto print, it is sent to the printer via some backend such as IPP."),(0,o.kt)("p",null,"Finally, the printer accepts a PostScript document as raw data and prints it\nout (some also support raster formats). This part of the process is largely\ncontrolled by the printer's onboard configuration, which can be modified by\nvisiting the printer's IP over the web (e.g. ",(0,o.kt)("inlineCode",{parentName:"p"},"https://papercut/"),"). In the OCF's\ncase, security is provided by an access control list (ACL) which accepts print\njobs from the printhost and rejects jobs from other hosts."),(0,o.kt)("h3",{id:"filters"},"Filters"),(0,o.kt)("p",null,"CUPS handles documents of many different formats. Some typical MIME types\ninclude ",(0,o.kt)("inlineCode",{parentName:"p"},"application/pdf")," for raw PDF and ",(0,o.kt)("inlineCode",{parentName:"p"},"application/vnd.cups-postscript")," for\nprintable PostScript. To convert between formats, CUPS runs the data through\nprograms called ",(0,o.kt)("em",{parentName:"p"},"filters"),". A filter is, basically, a program that takes a\nspecial call format, plus CUPS-specific environment variables, and converts\nfiles from one format to another while adding special formatting options like\nduplex mode."),(0,o.kt)("p",null,"CUPS uses not just one, but potentially several filters to get the document\ninto its final format. For example, a PDF file might go through ",(0,o.kt)("inlineCode",{parentName:"p"},"pdftops")," to\nconvert it to PostScript, then ",(0,o.kt)("inlineCode",{parentName:"p"},"pstops")," to insert print job options such as\nduplexing, then, finally, a device-specific filter such as ",(0,o.kt)("inlineCode",{parentName:"p"},"hpcups"),'. Each\nfilter is associated with an internal "cost", and CUPS picks the path with the\nleast total cost to print the document.'),(0,o.kt)("p",null,"At the OCF, print jobs are all processed by a single filter, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ocf/puppet/blob/master/modules/ocf_printhost/files/ocfps"},"ocfps"),",\nwhich converts raw PDFs to rasterized, printable PostScript. It calls on a\ncommand-line converter to render the PDF as pixels (rasterization), then passes\nthe result and the rest of the arguments to standard CUPS filters. So far, this\nhas given us the fewest headaches in terms of malformatted output and printer\nerrors."),(0,o.kt)("h3",{id:"drivers"},"Drivers"),(0,o.kt)("p",null,"In order to know what job options are available for a particular printer and\nhow to convert documents to a printable format, CUPS requires large config\nfiles called PostScript Printer Drivers (PPDs). The OCF uses a modified HP PPD\nfor the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ocf/puppet/blob/master/modules/ocf_printhost/templates/cups/ppd/m806.ppd.epp"},"M806"),'. There are two versions of it: one which only allows\ndouble-sided printing and one which only allows single-sided. This is how we\nimplement the "double" and "single" classes. The PPDs tell CUPS to use ',(0,o.kt)("inlineCode",{parentName:"p"},"ocfps"),"\nto convert documents to PostScript, plus they turn on economode so we can\nafford the toner."),(0,o.kt)("h2",{id:"print-accounting"},"Print accounting"),(0,o.kt)("p",null,"The OCF uses a virtual CUPS printer backend called ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.debian.org/Tea4CUPS"},"Tea4CUPS")," to\ninstall a page accounting hook that runs before and after each job is actually\nsent to the printer. The script is called ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ocf/puppet/blob/master/modules/ocf_printhost/files/enforcer"},"enforcer"),", but all the\nlogic is contained in the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ocf/ocflib/tree/master/ocflib/printing"},"ocflib printing package"),". All jobs\nare logged in the ",(0,o.kt)("inlineCode",{parentName:"p"},"ocfprinting")," SQL database, including the username, print\nqueue, and number of pages. Several views count up the number of pages printed\nby each user per day and per semester."),(0,o.kt)("p",null,"Page counting is actually done when the document is converted to PostScript,\nsince CUPS-processed PostScript includes the page count as a comment near the\ntop or bottom of the file. When enforcer receives a job that would put the user\nover daily or semesterly quota, it emails the user and returns an error code\nthat cancels the job. Otherwise, it logs successful print jobs in the database\nand emails users in the case a job fails."),(0,o.kt)("h3",{id:"desktop-notifications"},"Desktop notifications"),(0,o.kt)("p",null,"After printing a document from a desktop, lab visitors are notified when pages\nare subtracted from their quota by a little popup notification. This is done by\na short daemon script, ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ocf/puppet/blob/master/modules/ocf_desktop/files/xsession/notify"},"notify script"),", which starts upon login and\nruns the ",(0,o.kt)("a",{parentName:"p",href:"/docs/staff/scripts/paper"},"paper command")," every minute to see if the\nquota has changed."),(0,o.kt)("p",null,"In the future, it would be nice to have a more robust notification system where\nenforcer pushes notifications to desktops while a job is printing. This would\nallow for richer notifications to be displayed; namely, alerts to show when\na job has started or finished printing, whether the job printed successfully,\nand whether it went over quota. Current thinking is that this could be\nimplemented by broadcasting notifications to the whole network, or just the\ndesktops, and modifying the notify script to listen for messages about the\ncurrent user."),(0,o.kt)("h2",{id:"see-also"},"See also"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"/docs/staff/procedures/printing"},"Printing maintenance")),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ocf/puppet/tree/master/modules/ocf_printhost"},"ocf_printhost")," Puppet class"),(0,o.kt)("li",{parentName:"ul"},"The ",(0,o.kt)("a",{parentName:"li",href:"/docs/staff/scripts/paper"},"paper")," command"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/CUPS-printing.html"},"CUPS documentation at Samba")," (for Windows users, but has general\nCUPS info as well)")))}u.isMDXComponent=!0}}]);